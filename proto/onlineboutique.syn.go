// Code generated by protoc-gen-symphony. DO NOT EDIT.
package onlineboutique

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

func (m *CartItem) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (ProductId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of ProductId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.ProductId)))
	offset += len(m.ProductId)

	offset += 4 // Quantity

	// === DATA REGION SECTION ===

	// Write string or bytes field (ProductId)
	buf.Write([]byte(m.ProductId))

	// Write fixed field (Quantity)
	binary.Write(&buf, binary.LittleEndian, m.Quantity)

	return buf.Bytes(), nil
}

func (m *CartItem) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // ProductId
			// Unmarshal string or []byte field (ProductId)
			if entry, ok := offsets[1]; ok {
				m.ProductId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Quantity
			// Unmarshal fixed field (Quantity)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.Quantity); err != nil {
				return err
			}
			offset += 4
		}
	}

	return nil
}

func (m *AddItemRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 2 (Item): singular message
	if m.Item != nil {
		cachedSingularMessages[2], err = m.Item.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of UserId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.UserId)))
	offset += len(m.UserId)

	// Field 2 (Item): nested message
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[2])))
	offset += len(cachedSingularMessages[2])

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf.Write([]byte(m.UserId))

	// Write nested message field (Item)
	buf.Write(cachedSingularMessages[2])

	return buf.Bytes(), nil
}

func (m *AddItemRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Item
			// Unmarshal nested message field (Item)
			if entry, ok := offsets[2]; ok {
				if entry.length == 0 {
					m.Item = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Item == nil {
						m.Item = &CartItem{}
					}
					if err := m.Item.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *EmptyCartRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of UserId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.UserId)))
	offset += len(m.UserId)

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf.Write([]byte(m.UserId))

	return buf.Bytes(), nil
}

func (m *EmptyCartRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetCartRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of UserId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.UserId)))
	offset += len(m.UserId)

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf.Write([]byte(m.UserId))

	return buf.Bytes(), nil
}

func (m *GetCartRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Cart) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 2 (Items): repeated message
	cachedRepeatedMessages[2] = make([][]byte, len(m.Items))
	for i, item := range m.Items {
		if item != nil {
			cachedRepeatedMessages[2][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of UserId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.UserId)))
	offset += len(m.UserId)

	// Field 2 (Items): nested message
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	totalLen := 0
	for _, item := range cachedRepeatedMessages[2] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf.Write([]byte(m.UserId))

	// Write nested message field (Items)
	for _, item := range cachedRepeatedMessages[2] {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write(item)
	}

	return buf.Bytes(), nil
}

func (m *Cart) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Items
			// Unmarshal nested message field (Items)
			if entry, ok := offsets[2]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Items = make([]*CartItem, 0)
				itemReader := bytes.NewReader(fieldData)
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return err
					}
					itemBytes := make([]byte, itemLen)
					if _, err := itemReader.Read(itemBytes); err != nil {
						return err
					}
					newItem := &CartItem{}
					if itemLen == 0 {
						m.Items = append(m.Items, nil)
						continue
					}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return err
					}
					m.Items = append(m.Items, newItem)
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Empty) MarshalSymphony() ([]byte, error) {
	// Empty message - just return header
	return []byte{0x00}, nil
}

func (m *Empty) UnmarshalSymphony(data []byte) error {
	// Empty message - just validate header
	if len(data) < 1 || data[0] != 0x00 {
		return fmt.Errorf("invalid empty message data")
	}
	return nil
}

func (m *EmptyUser) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of UserId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.UserId)))
	offset += len(m.UserId)

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf.Write([]byte(m.UserId))

	return buf.Bytes(), nil
}

func (m *EmptyUser) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ListRecommendationsRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of UserId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.UserId)))
	offset += len(m.UserId)

	// Field 2 (ProductIds): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of ProductIds
	totalLen := 0
	for _, item := range m.ProductIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf.Write([]byte(m.UserId))

	// Write repeated variable-length field (ProductIds)
	for _, item := range m.ProductIds {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	return buf.Bytes(), nil
}

func (m *ListRecommendationsRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // ProductIds
			// Unmarshal repeated variable-length field (ProductIds)
			if entry, ok := offsets[2]; ok {
				m.ProductIds = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field ProductIds (2): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.ProductIds = append(m.ProductIds, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field ProductIds (2): error reading item data: %w", err)
					}
					m.ProductIds = append(m.ProductIds, string(itemData))
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ListRecommendationsResponse) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (ProductIds): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of ProductIds
	totalLen := 0
	for _, item := range m.ProductIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (ProductIds)
	for _, item := range m.ProductIds {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	return buf.Bytes(), nil
}

func (m *ListRecommendationsResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // ProductIds
			// Unmarshal repeated variable-length field (ProductIds)
			if entry, ok := offsets[1]; ok {
				m.ProductIds = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field ProductIds (1): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.ProductIds = append(m.ProductIds, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field ProductIds (1): error reading item data: %w", err)
					}
					m.ProductIds = append(m.ProductIds, string(itemData))
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Product) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 4, 5, 6})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 5 (PriceUsd): singular message
	if m.PriceUsd != nil {
		cachedSingularMessages[5], err = m.PriceUsd.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Id): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Id
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Id)))
	offset += len(m.Id)

	// Field 2 (Name): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Name
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Name)))
	offset += len(m.Name)

	// Field 3 (Description): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Description
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Description)))
	offset += len(m.Description)

	// Field 4 (Picture): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(4))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Picture
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Picture)))
	offset += len(m.Picture)

	// Field 5 (PriceUsd): nested message
	binary.Write(&buf, binary.LittleEndian, byte(5))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[5])))
	offset += len(cachedSingularMessages[5])

	// Field 6 (Categories): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(6))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Categories
	totalLen := 0
	for _, item := range m.Categories {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (Id)
	buf.Write([]byte(m.Id))

	// Write string or bytes field (Name)
	buf.Write([]byte(m.Name))

	// Write string or bytes field (Description)
	buf.Write([]byte(m.Description))

	// Write string or bytes field (Picture)
	buf.Write([]byte(m.Picture))

	// Write nested message field (PriceUsd)
	buf.Write(cachedSingularMessages[5])

	// Write repeated variable-length field (Categories)
	for _, item := range m.Categories {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	return buf.Bytes(), nil
}

func (m *Product) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 6)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 6; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Id
			// Unmarshal string or []byte field (Id)
			if entry, ok := offsets[1]; ok {
				m.Id = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Name
			// Unmarshal string or []byte field (Name)
			if entry, ok := offsets[2]; ok {
				m.Name = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 3: // Description
			// Unmarshal string or []byte field (Description)
			if entry, ok := offsets[3]; ok {
				m.Description = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 4: // Picture
			// Unmarshal string or []byte field (Picture)
			if entry, ok := offsets[4]; ok {
				m.Picture = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 5: // PriceUsd
			// Unmarshal nested message field (PriceUsd)
			if entry, ok := offsets[5]; ok {
				if entry.length == 0 {
					m.PriceUsd = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.PriceUsd == nil {
						m.PriceUsd = &Money{}
					}
					if err := m.PriceUsd.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		case 6: // Categories
			// Unmarshal repeated variable-length field (Categories)
			if entry, ok := offsets[6]; ok {
				m.Categories = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field Categories (6): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.Categories = append(m.Categories, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field Categories (6): error reading item data: %w", err)
					}
					m.Categories = append(m.Categories, string(itemData))
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ListProductsResponse) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 1 (Products): repeated message
	cachedRepeatedMessages[1] = make([][]byte, len(m.Products))
	for i, item := range m.Products {
		if item != nil {
			cachedRepeatedMessages[1][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Products): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	totalLen := 0
	for _, item := range cachedRepeatedMessages[1] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Products)
	for _, item := range cachedRepeatedMessages[1] {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write(item)
	}

	return buf.Bytes(), nil
}

func (m *ListProductsResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Products
			// Unmarshal nested message field (Products)
			if entry, ok := offsets[1]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Products = make([]*Product, 0)
				itemReader := bytes.NewReader(fieldData)
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return err
					}
					itemBytes := make([]byte, itemLen)
					if _, err := itemReader.Read(itemBytes); err != nil {
						return err
					}
					newItem := &Product{}
					if itemLen == 0 {
						m.Products = append(m.Products, nil)
						continue
					}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return err
					}
					m.Products = append(m.Products, newItem)
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetProductRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Id): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Id
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Id)))
	offset += len(m.Id)

	// === DATA REGION SECTION ===

	// Write string or bytes field (Id)
	buf.Write([]byte(m.Id))

	return buf.Bytes(), nil
}

func (m *GetProductRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Id
			// Unmarshal string or []byte field (Id)
			if entry, ok := offsets[1]; ok {
				m.Id = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SearchProductsRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Query): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Query
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Query)))
	offset += len(m.Query)

	// === DATA REGION SECTION ===

	// Write string or bytes field (Query)
	buf.Write([]byte(m.Query))

	return buf.Bytes(), nil
}

func (m *SearchProductsRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Query
			// Unmarshal string or []byte field (Query)
			if entry, ok := offsets[1]; ok {
				m.Query = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SearchProductsResponse) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 1 (Results): repeated message
	cachedRepeatedMessages[1] = make([][]byte, len(m.Results))
	for i, item := range m.Results {
		if item != nil {
			cachedRepeatedMessages[1][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Results): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	totalLen := 0
	for _, item := range cachedRepeatedMessages[1] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Results)
	for _, item := range cachedRepeatedMessages[1] {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write(item)
	}

	return buf.Bytes(), nil
}

func (m *SearchProductsResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Results
			// Unmarshal nested message field (Results)
			if entry, ok := offsets[1]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Results = make([]*Product, 0)
				itemReader := bytes.NewReader(fieldData)
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return err
					}
					itemBytes := make([]byte, itemLen)
					if _, err := itemReader.Read(itemBytes); err != nil {
						return err
					}
					newItem := &Product{}
					if itemLen == 0 {
						m.Results = append(m.Results, nil)
						continue
					}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return err
					}
					m.Results = append(m.Results, newItem)
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetQuoteRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (Address): singular message
	if m.Address != nil {
		cachedSingularMessages[1], err = m.Address.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 2 (Items): repeated message
	cachedRepeatedMessages[2] = make([][]byte, len(m.Items))
	for i, item := range m.Items {
		if item != nil {
			cachedRepeatedMessages[2][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Address): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[1])))
	offset += len(cachedSingularMessages[1])

	// Field 2 (Items): nested message
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	totalLen := 0
	for _, item := range cachedRepeatedMessages[2] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Address)
	buf.Write(cachedSingularMessages[1])

	// Write nested message field (Items)
	for _, item := range cachedRepeatedMessages[2] {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write(item)
	}

	return buf.Bytes(), nil
}

func (m *GetQuoteRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Address
			// Unmarshal nested message field (Address)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.Address = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Address == nil {
						m.Address = &Address{}
					}
					if err := m.Address.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		case 2: // Items
			// Unmarshal nested message field (Items)
			if entry, ok := offsets[2]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Items = make([]*CartItem, 0)
				itemReader := bytes.NewReader(fieldData)
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return err
					}
					itemBytes := make([]byte, itemLen)
					if _, err := itemReader.Read(itemBytes); err != nil {
						return err
					}
					newItem := &CartItem{}
					if itemLen == 0 {
						m.Items = append(m.Items, nil)
						continue
					}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return err
					}
					m.Items = append(m.Items, newItem)
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetQuoteResponse) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (CostUsd): singular message
	if m.CostUsd != nil {
		cachedSingularMessages[1], err = m.CostUsd.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (CostUsd): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[1])))
	offset += len(cachedSingularMessages[1])

	// === DATA REGION SECTION ===

	// Write nested message field (CostUsd)
	buf.Write(cachedSingularMessages[1])

	return buf.Bytes(), nil
}

func (m *GetQuoteResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // CostUsd
			// Unmarshal nested message field (CostUsd)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.CostUsd = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.CostUsd == nil {
						m.CostUsd = &Money{}
					}
					if err := m.CostUsd.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ShipOrderRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (Address): singular message
	if m.Address != nil {
		cachedSingularMessages[1], err = m.Address.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 2 (Items): repeated message
	cachedRepeatedMessages[2] = make([][]byte, len(m.Items))
	for i, item := range m.Items {
		if item != nil {
			cachedRepeatedMessages[2][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Address): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[1])))
	offset += len(cachedSingularMessages[1])

	// Field 2 (Items): nested message
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	totalLen := 0
	for _, item := range cachedRepeatedMessages[2] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Address)
	buf.Write(cachedSingularMessages[1])

	// Write nested message field (Items)
	for _, item := range cachedRepeatedMessages[2] {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write(item)
	}

	return buf.Bytes(), nil
}

func (m *ShipOrderRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Address
			// Unmarshal nested message field (Address)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.Address = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Address == nil {
						m.Address = &Address{}
					}
					if err := m.Address.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		case 2: // Items
			// Unmarshal nested message field (Items)
			if entry, ok := offsets[2]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Items = make([]*CartItem, 0)
				itemReader := bytes.NewReader(fieldData)
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return err
					}
					itemBytes := make([]byte, itemLen)
					if _, err := itemReader.Read(itemBytes); err != nil {
						return err
					}
					newItem := &CartItem{}
					if itemLen == 0 {
						m.Items = append(m.Items, nil)
						continue
					}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return err
					}
					m.Items = append(m.Items, newItem)
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ShipOrderResponse) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (TrackingId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of TrackingId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.TrackingId)))
	offset += len(m.TrackingId)

	// === DATA REGION SECTION ===

	// Write string or bytes field (TrackingId)
	buf.Write([]byte(m.TrackingId))

	return buf.Bytes(), nil
}

func (m *ShipOrderResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // TrackingId
			// Unmarshal string or []byte field (TrackingId)
			if entry, ok := offsets[1]; ok {
				m.TrackingId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Address) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 4, 5})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (StreetAddress): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of StreetAddress
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.StreetAddress)))
	offset += len(m.StreetAddress)

	// Field 2 (City): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of City
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.City)))
	offset += len(m.City)

	// Field 3 (State): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of State
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.State)))
	offset += len(m.State)

	// Field 4 (Country): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(4))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Country
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Country)))
	offset += len(m.Country)

	offset += 4 // ZipCode

	// === DATA REGION SECTION ===

	// Write string or bytes field (StreetAddress)
	buf.Write([]byte(m.StreetAddress))

	// Write string or bytes field (City)
	buf.Write([]byte(m.City))

	// Write string or bytes field (State)
	buf.Write([]byte(m.State))

	// Write string or bytes field (Country)
	buf.Write([]byte(m.Country))

	// Write fixed field (ZipCode)
	binary.Write(&buf, binary.LittleEndian, m.ZipCode)

	return buf.Bytes(), nil
}

func (m *Address) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 5)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 4; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // StreetAddress
			// Unmarshal string or []byte field (StreetAddress)
			if entry, ok := offsets[1]; ok {
				m.StreetAddress = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // City
			// Unmarshal string or []byte field (City)
			if entry, ok := offsets[2]; ok {
				m.City = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 3: // State
			// Unmarshal string or []byte field (State)
			if entry, ok := offsets[3]; ok {
				m.State = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 4: // Country
			// Unmarshal string or []byte field (Country)
			if entry, ok := offsets[4]; ok {
				m.Country = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 5: // ZipCode
			// Unmarshal fixed field (ZipCode)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.ZipCode); err != nil {
				return err
			}
			offset += 4
		}
	}

	return nil
}

func (m *Money) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (CurrencyCode): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of CurrencyCode
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.CurrencyCode)))
	offset += len(m.CurrencyCode)

	offset += 8 // Units

	offset += 4 // Nanos

	// === DATA REGION SECTION ===

	// Write string or bytes field (CurrencyCode)
	buf.Write([]byte(m.CurrencyCode))

	// Write fixed field (Units)
	binary.Write(&buf, binary.LittleEndian, m.Units)

	// Write fixed field (Nanos)
	binary.Write(&buf, binary.LittleEndian, m.Nanos)

	return buf.Bytes(), nil
}

func (m *Money) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 3)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // CurrencyCode
			// Unmarshal string or []byte field (CurrencyCode)
			if entry, ok := offsets[1]; ok {
				m.CurrencyCode = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Units
			// Unmarshal fixed field (Units)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+8]), binary.LittleEndian, &m.Units); err != nil {
				return err
			}
			offset += 8
		case 3: // Nanos
			// Unmarshal fixed field (Nanos)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.Nanos); err != nil {
				return err
			}
			offset += 4
		}
	}

	return nil
}

func (m *GetSupportedCurrenciesResponse) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (CurrencyCodes): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of CurrencyCodes
	totalLen := 0
	for _, item := range m.CurrencyCodes {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (CurrencyCodes)
	for _, item := range m.CurrencyCodes {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	return buf.Bytes(), nil
}

func (m *GetSupportedCurrenciesResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // CurrencyCodes
			// Unmarshal repeated variable-length field (CurrencyCodes)
			if entry, ok := offsets[1]; ok {
				m.CurrencyCodes = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field CurrencyCodes (1): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.CurrencyCodes = append(m.CurrencyCodes, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field CurrencyCodes (1): error reading item data: %w", err)
					}
					m.CurrencyCodes = append(m.CurrencyCodes, string(itemData))
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *CurrencyConversionRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (From): singular message
	if m.From != nil {
		cachedSingularMessages[1], err = m.From.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (From): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[1])))
	offset += len(cachedSingularMessages[1])

	// Field 2 (ToCode): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of ToCode
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.ToCode)))
	offset += len(m.ToCode)

	// Field 3 (UserId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of UserId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.UserId)))
	offset += len(m.UserId)

	// === DATA REGION SECTION ===

	// Write nested message field (From)
	buf.Write(cachedSingularMessages[1])

	// Write string or bytes field (ToCode)
	buf.Write([]byte(m.ToCode))

	// Write string or bytes field (UserId)
	buf.Write([]byte(m.UserId))

	return buf.Bytes(), nil
}

func (m *CurrencyConversionRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 3)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 3; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // From
			// Unmarshal nested message field (From)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.From = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.From == nil {
						m.From = &Money{}
					}
					if err := m.From.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		case 2: // ToCode
			// Unmarshal string or []byte field (ToCode)
			if entry, ok := offsets[2]; ok {
				m.ToCode = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 3: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[3]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *CreditCardInfo) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 4})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (CreditCardNumber): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of CreditCardNumber
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.CreditCardNumber)))
	offset += len(m.CreditCardNumber)

	offset += 4 // CreditCardCvv

	offset += 4 // CreditCardExpirationYear

	offset += 4 // CreditCardExpirationMonth

	// === DATA REGION SECTION ===

	// Write string or bytes field (CreditCardNumber)
	buf.Write([]byte(m.CreditCardNumber))

	// Write fixed field (CreditCardCvv)
	binary.Write(&buf, binary.LittleEndian, m.CreditCardCvv)

	// Write fixed field (CreditCardExpirationYear)
	binary.Write(&buf, binary.LittleEndian, m.CreditCardExpirationYear)

	// Write fixed field (CreditCardExpirationMonth)
	binary.Write(&buf, binary.LittleEndian, m.CreditCardExpirationMonth)

	return buf.Bytes(), nil
}

func (m *CreditCardInfo) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 4)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // CreditCardNumber
			// Unmarshal string or []byte field (CreditCardNumber)
			if entry, ok := offsets[1]; ok {
				m.CreditCardNumber = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // CreditCardCvv
			// Unmarshal fixed field (CreditCardCvv)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.CreditCardCvv); err != nil {
				return err
			}
			offset += 4
		case 3: // CreditCardExpirationYear
			// Unmarshal fixed field (CreditCardExpirationYear)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.CreditCardExpirationYear); err != nil {
				return err
			}
			offset += 4
		case 4: // CreditCardExpirationMonth
			// Unmarshal fixed field (CreditCardExpirationMonth)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.CreditCardExpirationMonth); err != nil {
				return err
			}
			offset += 4
		}
	}

	return nil
}

func (m *ChargeRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (Amount): singular message
	if m.Amount != nil {
		cachedSingularMessages[1], err = m.Amount.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// Cache field 2 (CreditCard): singular message
	if m.CreditCard != nil {
		cachedSingularMessages[2], err = m.CreditCard.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Amount): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[1])))
	offset += len(cachedSingularMessages[1])

	// Field 2 (CreditCard): nested message
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[2])))
	offset += len(cachedSingularMessages[2])

	// === DATA REGION SECTION ===

	// Write nested message field (Amount)
	buf.Write(cachedSingularMessages[1])

	// Write nested message field (CreditCard)
	buf.Write(cachedSingularMessages[2])

	return buf.Bytes(), nil
}

func (m *ChargeRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Amount
			// Unmarshal nested message field (Amount)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.Amount = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Amount == nil {
						m.Amount = &Money{}
					}
					if err := m.Amount.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		case 2: // CreditCard
			// Unmarshal nested message field (CreditCard)
			if entry, ok := offsets[2]; ok {
				if entry.length == 0 {
					m.CreditCard = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.CreditCard == nil {
						m.CreditCard = &CreditCardInfo{}
					}
					if err := m.CreditCard.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ChargeResponse) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (TransactionId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of TransactionId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.TransactionId)))
	offset += len(m.TransactionId)

	// === DATA REGION SECTION ===

	// Write string or bytes field (TransactionId)
	buf.Write([]byte(m.TransactionId))

	return buf.Bytes(), nil
}

func (m *ChargeResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // TransactionId
			// Unmarshal string or []byte field (TransactionId)
			if entry, ok := offsets[1]; ok {
				m.TransactionId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *OrderItem) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (Item): singular message
	if m.Item != nil {
		cachedSingularMessages[1], err = m.Item.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// Cache field 2 (Cost): singular message
	if m.Cost != nil {
		cachedSingularMessages[2], err = m.Cost.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Item): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[1])))
	offset += len(cachedSingularMessages[1])

	// Field 2 (Cost): nested message
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[2])))
	offset += len(cachedSingularMessages[2])

	// === DATA REGION SECTION ===

	// Write nested message field (Item)
	buf.Write(cachedSingularMessages[1])

	// Write nested message field (Cost)
	buf.Write(cachedSingularMessages[2])

	return buf.Bytes(), nil
}

func (m *OrderItem) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Item
			// Unmarshal nested message field (Item)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.Item = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Item == nil {
						m.Item = &CartItem{}
					}
					if err := m.Item.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		case 2: // Cost
			// Unmarshal nested message field (Cost)
			if entry, ok := offsets[2]; ok {
				if entry.length == 0 {
					m.Cost = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Cost == nil {
						m.Cost = &Money{}
					}
					if err := m.Cost.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *OrderResult) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 4, 5})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 3 (ShippingCost): singular message
	if m.ShippingCost != nil {
		cachedSingularMessages[3], err = m.ShippingCost.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// Cache field 4 (ShippingAddress): singular message
	if m.ShippingAddress != nil {
		cachedSingularMessages[4], err = m.ShippingAddress.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 5 (Items): repeated message
	cachedRepeatedMessages[5] = make([][]byte, len(m.Items))
	for i, item := range m.Items {
		if item != nil {
			cachedRepeatedMessages[5][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (OrderId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of OrderId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.OrderId)))
	offset += len(m.OrderId)

	// Field 2 (ShippingTrackingId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of ShippingTrackingId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.ShippingTrackingId)))
	offset += len(m.ShippingTrackingId)

	// Field 3 (ShippingCost): nested message
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[3])))
	offset += len(cachedSingularMessages[3])

	// Field 4 (ShippingAddress): nested message
	binary.Write(&buf, binary.LittleEndian, byte(4))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[4])))
	offset += len(cachedSingularMessages[4])

	// Field 5 (Items): nested message
	binary.Write(&buf, binary.LittleEndian, byte(5))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	totalLen := 0
	for _, item := range cachedRepeatedMessages[5] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (OrderId)
	buf.Write([]byte(m.OrderId))

	// Write string or bytes field (ShippingTrackingId)
	buf.Write([]byte(m.ShippingTrackingId))

	// Write nested message field (ShippingCost)
	buf.Write(cachedSingularMessages[3])

	// Write nested message field (ShippingAddress)
	buf.Write(cachedSingularMessages[4])

	// Write nested message field (Items)
	for _, item := range cachedRepeatedMessages[5] {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write(item)
	}

	return buf.Bytes(), nil
}

func (m *OrderResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 5)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 5; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // OrderId
			// Unmarshal string or []byte field (OrderId)
			if entry, ok := offsets[1]; ok {
				m.OrderId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // ShippingTrackingId
			// Unmarshal string or []byte field (ShippingTrackingId)
			if entry, ok := offsets[2]; ok {
				m.ShippingTrackingId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 3: // ShippingCost
			// Unmarshal nested message field (ShippingCost)
			if entry, ok := offsets[3]; ok {
				if entry.length == 0 {
					m.ShippingCost = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.ShippingCost == nil {
						m.ShippingCost = &Money{}
					}
					if err := m.ShippingCost.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		case 4: // ShippingAddress
			// Unmarshal nested message field (ShippingAddress)
			if entry, ok := offsets[4]; ok {
				if entry.length == 0 {
					m.ShippingAddress = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.ShippingAddress == nil {
						m.ShippingAddress = &Address{}
					}
					if err := m.ShippingAddress.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		case 5: // Items
			// Unmarshal nested message field (Items)
			if entry, ok := offsets[5]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Items = make([]*OrderItem, 0)
				itemReader := bytes.NewReader(fieldData)
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return err
					}
					itemBytes := make([]byte, itemLen)
					if _, err := itemReader.Read(itemBytes); err != nil {
						return err
					}
					newItem := &OrderItem{}
					if itemLen == 0 {
						m.Items = append(m.Items, nil)
						continue
					}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return err
					}
					m.Items = append(m.Items, newItem)
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SendOrderConfirmationRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 2 (Order): singular message
	if m.Order != nil {
		cachedSingularMessages[2], err = m.Order.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Email): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Email
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Email)))
	offset += len(m.Email)

	// Field 2 (Order): nested message
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[2])))
	offset += len(cachedSingularMessages[2])

	// === DATA REGION SECTION ===

	// Write string or bytes field (Email)
	buf.Write([]byte(m.Email))

	// Write nested message field (Order)
	buf.Write(cachedSingularMessages[2])

	return buf.Bytes(), nil
}

func (m *SendOrderConfirmationRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Email
			// Unmarshal string or []byte field (Email)
			if entry, ok := offsets[1]; ok {
				m.Email = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Order
			// Unmarshal nested message field (Order)
			if entry, ok := offsets[2]; ok {
				if entry.length == 0 {
					m.Order = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Order == nil {
						m.Order = &OrderResult{}
					}
					if err := m.Order.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *PlaceOrderRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 5, 6})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 3 (Address): singular message
	if m.Address != nil {
		cachedSingularMessages[3], err = m.Address.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// Cache field 6 (CreditCard): singular message
	if m.CreditCard != nil {
		cachedSingularMessages[6], err = m.CreditCard.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of UserId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.UserId)))
	offset += len(m.UserId)

	// Field 2 (UserCurrency): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of UserCurrency
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.UserCurrency)))
	offset += len(m.UserCurrency)

	// Field 3 (Address): nested message
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[3])))
	offset += len(cachedSingularMessages[3])

	// Field 5 (Email): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(5))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Email
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Email)))
	offset += len(m.Email)

	// Field 6 (CreditCard): nested message
	binary.Write(&buf, binary.LittleEndian, byte(6))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[6])))
	offset += len(cachedSingularMessages[6])

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf.Write([]byte(m.UserId))

	// Write string or bytes field (UserCurrency)
	buf.Write([]byte(m.UserCurrency))

	// Write nested message field (Address)
	buf.Write(cachedSingularMessages[3])

	// Write string or bytes field (Email)
	buf.Write([]byte(m.Email))

	// Write nested message field (CreditCard)
	buf.Write(cachedSingularMessages[6])

	return buf.Bytes(), nil
}

func (m *PlaceOrderRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 5)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 5; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // UserCurrency
			// Unmarshal string or []byte field (UserCurrency)
			if entry, ok := offsets[2]; ok {
				m.UserCurrency = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 3: // Address
			// Unmarshal nested message field (Address)
			if entry, ok := offsets[3]; ok {
				if entry.length == 0 {
					m.Address = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Address == nil {
						m.Address = &Address{}
					}
					if err := m.Address.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		case 5: // Email
			// Unmarshal string or []byte field (Email)
			if entry, ok := offsets[5]; ok {
				m.Email = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 6: // CreditCard
			// Unmarshal nested message field (CreditCard)
			if entry, ok := offsets[6]; ok {
				if entry.length == 0 {
					m.CreditCard = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.CreditCard == nil {
						m.CreditCard = &CreditCardInfo{}
					}
					if err := m.CreditCard.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *PlaceOrderResponse) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (Order): singular message
	if m.Order != nil {
		cachedSingularMessages[1], err = m.Order.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Order): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[1])))
	offset += len(cachedSingularMessages[1])

	// === DATA REGION SECTION ===

	// Write nested message field (Order)
	buf.Write(cachedSingularMessages[1])

	return buf.Bytes(), nil
}

func (m *PlaceOrderResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Order
			// Unmarshal nested message field (Order)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.Order = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Order == nil {
						m.Order = &OrderResult{}
					}
					if err := m.Order.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *AdRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of UserId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.UserId)))
	offset += len(m.UserId)

	// Field 2 (ContextKeys): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of ContextKeys
	totalLen := 0
	for _, item := range m.ContextKeys {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf.Write([]byte(m.UserId))

	// Write repeated variable-length field (ContextKeys)
	for _, item := range m.ContextKeys {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	return buf.Bytes(), nil
}

func (m *AdRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // ContextKeys
			// Unmarshal repeated variable-length field (ContextKeys)
			if entry, ok := offsets[2]; ok {
				m.ContextKeys = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field ContextKeys (2): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.ContextKeys = append(m.ContextKeys, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field ContextKeys (2): error reading item data: %w", err)
					}
					m.ContextKeys = append(m.ContextKeys, string(itemData))
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *AdResponse) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 1 (Ads): repeated message
	cachedRepeatedMessages[1] = make([][]byte, len(m.Ads))
	for i, item := range m.Ads {
		if item != nil {
			cachedRepeatedMessages[1][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Ads): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	totalLen := 0
	for _, item := range cachedRepeatedMessages[1] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Ads)
	for _, item := range cachedRepeatedMessages[1] {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write(item)
	}

	return buf.Bytes(), nil
}

func (m *AdResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Ads
			// Unmarshal nested message field (Ads)
			if entry, ok := offsets[1]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Ads = make([]*Ad, 0)
				itemReader := bytes.NewReader(fieldData)
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return err
					}
					itemBytes := make([]byte, itemLen)
					if _, err := itemReader.Read(itemBytes); err != nil {
						return err
					}
					newItem := &Ad{}
					if itemLen == 0 {
						m.Ads = append(m.Ads, nil)
						continue
					}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return err
					}
					m.Ads = append(m.Ads, newItem)
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Ad) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (RedirectUrl): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of RedirectUrl
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.RedirectUrl)))
	offset += len(m.RedirectUrl)

	// Field 2 (Text): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Text
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Text)))
	offset += len(m.Text)

	// === DATA REGION SECTION ===

	// Write string or bytes field (RedirectUrl)
	buf.Write([]byte(m.RedirectUrl))

	// Write string or bytes field (Text)
	buf.Write([]byte(m.Text))

	return buf.Bytes(), nil
}

func (m *Ad) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // RedirectUrl
			// Unmarshal string or []byte field (RedirectUrl)
			if entry, ok := offsets[1]; ok {
				m.RedirectUrl = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Text
			// Unmarshal string or []byte field (Text)
			if entry, ok := offsets[2]; ok {
				m.Text = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}
