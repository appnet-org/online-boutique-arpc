// Code generated by protoc-gen-symphony. DO NOT EDIT.
package onlineboutique

import (
	"encoding/binary"
	"fmt"
)

func (m *CartItem) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 55)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (ProductId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of ProductId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.ProductId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.ProductId)

	offset += 4 // Quantity

	// === DATA REGION SECTION ===

	// Write string or bytes field (ProductId)
	buf = append(buf, []byte(m.ProductId)...)

	// Write fixed field (Quantity)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.Quantity))
	buf = append(buf, temp[:4]...)

	return buf, nil
}

func (m *CartItem) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // ProductId
			// Unmarshal string or []byte field (ProductId)
			if entry, ok := offsets[1]; ok {
				m.ProductId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Quantity
			// Unmarshal fixed field (Quantity)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Quantity = int32(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		}
	}

	return nil
}

func (m *AddItemRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 136)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 2 (Item): singular message
	if m.Item != nil {
		cachedSingularMessages[2], err = m.Item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field Item: %w", err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of UserId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.UserId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.UserId)

	// Field 2 (Item): nested message
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[2])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[2])

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf = append(buf, []byte(m.UserId)...)

	// Write nested message field (Item)
	buf = append(buf, cachedSingularMessages[2]...)

	return buf, nil
}

func (m *AddItemRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Item
			// Unmarshal nested message field (Item)
			if entry, ok := offsets[2]; ok {
				if entry.length == 0 {
					m.Item = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Item == nil {
						m.Item = &CartItem{}
					}
					if err := m.Item.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *EmptyCartRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of UserId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.UserId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.UserId)

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf = append(buf, []byte(m.UserId)...)

	return buf, nil
}

func (m *EmptyCartRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetCartRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of UserId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.UserId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.UserId)

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf = append(buf, []byte(m.UserId)...)

	return buf, nil
}

func (m *GetCartRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Cart) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 136)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 2 (Items): repeated message
	cachedRepeatedMessages[2] = make([][]byte, len(m.Items))
	for i, item := range m.Items {
		if item != nil {
			cachedRepeatedMessages[2][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, fmt.Errorf("failed to marshal repeated message field Items[%d]: %w", i, err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of UserId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.UserId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.UserId)

	// Field 2 (Items): nested message
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range cachedRepeatedMessages[2] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf = append(buf, []byte(m.UserId)...)

	// Write nested message field (Items)
	for _, item := range cachedRepeatedMessages[2] {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, item...)
	}

	return buf, nil
}

func (m *Cart) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Items
			// Unmarshal nested message field (Items)
			if entry, ok := offsets[2]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Items = make([]*CartItem, 0)
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.Items = append(m.Items, nil)
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item bytes")
					}
					itemBytes := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					newItem := &CartItem{}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return fmt.Errorf("failed to unmarshal nested message: %w", err)
					}
					m.Items = append(m.Items, newItem)
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Empty) MarshalSymphony() ([]byte, error) {
	// Empty message - just return header
	return []byte{0x00}, nil
}

func (m *Empty) UnmarshalSymphony(data []byte) error {
	// Empty message - just validate header
	if len(data) < 1 || data[0] != 0x00 {
		return fmt.Errorf("invalid empty message data")
	}
	return nil
}

func (m *EmptyUser) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of UserId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.UserId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.UserId)

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf = append(buf, []byte(m.UserId)...)

	return buf, nil
}

func (m *EmptyUser) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ListRecommendationsRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 96)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of UserId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.UserId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.UserId)

	// Field 2 (ProductIds): repeated variable-length
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of ProductIds
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.ProductIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf = append(buf, []byte(m.UserId)...)

	// Write repeated variable-length field (ProductIds)
	for _, item := range m.ProductIds {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	return buf, nil
}

func (m *ListRecommendationsRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // ProductIds
			// Unmarshal repeated variable-length field (ProductIds)
			if entry, ok := offsets[2]; ok {
				m.ProductIds = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.ProductIds = append(m.ProductIds, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.ProductIds = append(m.ProductIds, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ListRecommendationsResponse) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (ProductIds): repeated variable-length
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of ProductIds
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.ProductIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (ProductIds)
	for _, item := range m.ProductIds {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	return buf, nil
}

func (m *ListRecommendationsResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // ProductIds
			// Unmarshal repeated variable-length field (ProductIds)
			if entry, ok := offsets[1]; ok {
				m.ProductIds = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.ProductIds = append(m.ProductIds, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.ProductIds = append(m.ProductIds, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Product) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 326)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4, 5, 6}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 5 (PriceUsd): singular message
	if m.PriceUsd != nil {
		cachedSingularMessages[5], err = m.PriceUsd.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field PriceUsd: %w", err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Id): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Id
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Id)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Id)

	// Field 2 (Name): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Name
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Name)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Name)

	// Field 3 (Description): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Description
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Description)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Description)

	// Field 4 (Picture): string or bytes
	buf = append(buf, byte(4))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Picture
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Picture)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Picture)

	// Field 5 (PriceUsd): nested message
	buf = append(buf, byte(5))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[5])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[5])

	// Field 6 (Categories): repeated variable-length
	buf = append(buf, byte(6))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Categories
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.Categories {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (Id)
	buf = append(buf, []byte(m.Id)...)

	// Write string or bytes field (Name)
	buf = append(buf, []byte(m.Name)...)

	// Write string or bytes field (Description)
	buf = append(buf, []byte(m.Description)...)

	// Write string or bytes field (Picture)
	buf = append(buf, []byte(m.Picture)...)

	// Write nested message field (PriceUsd)
	buf = append(buf, cachedSingularMessages[5]...)

	// Write repeated variable-length field (Categories)
	for _, item := range m.Categories {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	return buf, nil
}

func (m *Product) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 7 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+6]
	offset += 6

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 30
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 6; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Id
			// Unmarshal string or []byte field (Id)
			if entry, ok := offsets[1]; ok {
				m.Id = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Name
			// Unmarshal string or []byte field (Name)
			if entry, ok := offsets[2]; ok {
				m.Name = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 3: // Description
			// Unmarshal string or []byte field (Description)
			if entry, ok := offsets[3]; ok {
				m.Description = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 4: // Picture
			// Unmarshal string or []byte field (Picture)
			if entry, ok := offsets[4]; ok {
				m.Picture = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 5: // PriceUsd
			// Unmarshal nested message field (PriceUsd)
			if entry, ok := offsets[5]; ok {
				if entry.length == 0 {
					m.PriceUsd = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.PriceUsd == nil {
						m.PriceUsd = &Money{}
					}
					if err := m.PriceUsd.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		case 6: // Categories
			// Unmarshal repeated variable-length field (Categories)
			if entry, ok := offsets[6]; ok {
				m.Categories = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.Categories = append(m.Categories, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.Categories = append(m.Categories, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ListProductsResponse) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 88)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 1 (Products): repeated message
	cachedRepeatedMessages[1] = make([][]byte, len(m.Products))
	for i, item := range m.Products {
		if item != nil {
			cachedRepeatedMessages[1][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, fmt.Errorf("failed to marshal repeated message field Products[%d]: %w", i, err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Products): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range cachedRepeatedMessages[1] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Products)
	for _, item := range cachedRepeatedMessages[1] {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, item...)
	}

	return buf, nil
}

func (m *ListProductsResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Products
			// Unmarshal nested message field (Products)
			if entry, ok := offsets[1]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Products = make([]*Product, 0)
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.Products = append(m.Products, nil)
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item bytes")
					}
					itemBytes := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					newItem := &Product{}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return fmt.Errorf("failed to unmarshal nested message: %w", err)
					}
					m.Products = append(m.Products, newItem)
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetProductRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Id): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Id
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Id)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Id)

	// === DATA REGION SECTION ===

	// Write string or bytes field (Id)
	buf = append(buf, []byte(m.Id)...)

	return buf, nil
}

func (m *GetProductRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Id
			// Unmarshal string or []byte field (Id)
			if entry, ok := offsets[1]; ok {
				m.Id = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SearchProductsRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Query): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Query
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Query)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Query)

	// === DATA REGION SECTION ===

	// Write string or bytes field (Query)
	buf = append(buf, []byte(m.Query)...)

	return buf, nil
}

func (m *SearchProductsRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Query
			// Unmarshal string or []byte field (Query)
			if entry, ok := offsets[1]; ok {
				m.Query = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SearchProductsResponse) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 88)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 1 (Results): repeated message
	cachedRepeatedMessages[1] = make([][]byte, len(m.Results))
	for i, item := range m.Results {
		if item != nil {
			cachedRepeatedMessages[1][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, fmt.Errorf("failed to marshal repeated message field Results[%d]: %w", i, err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Results): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range cachedRepeatedMessages[1] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Results)
	for _, item := range cachedRepeatedMessages[1] {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, item...)
	}

	return buf, nil
}

func (m *SearchProductsResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Results
			// Unmarshal nested message field (Results)
			if entry, ok := offsets[1]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Results = make([]*Product, 0)
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.Results = append(m.Results, nil)
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item bytes")
					}
					itemBytes := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					newItem := &Product{}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return fmt.Errorf("failed to unmarshal nested message: %w", err)
					}
					m.Results = append(m.Results, newItem)
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetQuoteRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 176)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (Address): singular message
	if m.Address != nil {
		cachedSingularMessages[1], err = m.Address.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field Address: %w", err)
		}
	}

	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 2 (Items): repeated message
	cachedRepeatedMessages[2] = make([][]byte, len(m.Items))
	for i, item := range m.Items {
		if item != nil {
			cachedRepeatedMessages[2][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, fmt.Errorf("failed to marshal repeated message field Items[%d]: %w", i, err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Address): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[1])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[1])

	// Field 2 (Items): nested message
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range cachedRepeatedMessages[2] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Address)
	buf = append(buf, cachedSingularMessages[1]...)

	// Write nested message field (Items)
	for _, item := range cachedRepeatedMessages[2] {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, item...)
	}

	return buf, nil
}

func (m *GetQuoteRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Address
			// Unmarshal nested message field (Address)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.Address = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Address == nil {
						m.Address = &Address{}
					}
					if err := m.Address.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		case 2: // Items
			// Unmarshal nested message field (Items)
			if entry, ok := offsets[2]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Items = make([]*CartItem, 0)
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.Items = append(m.Items, nil)
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item bytes")
					}
					itemBytes := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					newItem := &CartItem{}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return fmt.Errorf("failed to unmarshal nested message: %w", err)
					}
					m.Items = append(m.Items, newItem)
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetQuoteResponse) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 88)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (CostUsd): singular message
	if m.CostUsd != nil {
		cachedSingularMessages[1], err = m.CostUsd.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field CostUsd: %w", err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (CostUsd): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[1])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[1])

	// === DATA REGION SECTION ===

	// Write nested message field (CostUsd)
	buf = append(buf, cachedSingularMessages[1]...)

	return buf, nil
}

func (m *GetQuoteResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // CostUsd
			// Unmarshal nested message field (CostUsd)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.CostUsd = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.CostUsd == nil {
						m.CostUsd = &Money{}
					}
					if err := m.CostUsd.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ShipOrderRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 176)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (Address): singular message
	if m.Address != nil {
		cachedSingularMessages[1], err = m.Address.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field Address: %w", err)
		}
	}

	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 2 (Items): repeated message
	cachedRepeatedMessages[2] = make([][]byte, len(m.Items))
	for i, item := range m.Items {
		if item != nil {
			cachedRepeatedMessages[2][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, fmt.Errorf("failed to marshal repeated message field Items[%d]: %w", i, err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Address): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[1])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[1])

	// Field 2 (Items): nested message
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range cachedRepeatedMessages[2] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Address)
	buf = append(buf, cachedSingularMessages[1]...)

	// Write nested message field (Items)
	for _, item := range cachedRepeatedMessages[2] {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, item...)
	}

	return buf, nil
}

func (m *ShipOrderRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Address
			// Unmarshal nested message field (Address)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.Address = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Address == nil {
						m.Address = &Address{}
					}
					if err := m.Address.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		case 2: // Items
			// Unmarshal nested message field (Items)
			if entry, ok := offsets[2]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Items = make([]*CartItem, 0)
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.Items = append(m.Items, nil)
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item bytes")
					}
					itemBytes := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					newItem := &CartItem{}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return fmt.Errorf("failed to unmarshal nested message: %w", err)
					}
					m.Items = append(m.Items, newItem)
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ShipOrderResponse) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (TrackingId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of TrackingId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.TrackingId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.TrackingId)

	// === DATA REGION SECTION ===

	// Write string or bytes field (TrackingId)
	buf = append(buf, []byte(m.TrackingId)...)

	return buf, nil
}

func (m *ShipOrderResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // TrackingId
			// Unmarshal string or []byte field (TrackingId)
			if entry, ok := offsets[1]; ok {
				m.TrackingId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Address) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 197)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4, 5}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (StreetAddress): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of StreetAddress
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.StreetAddress)))
	buf = append(buf, temp[:2]...)
	offset += len(m.StreetAddress)

	// Field 2 (City): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of City
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.City)))
	buf = append(buf, temp[:2]...)
	offset += len(m.City)

	// Field 3 (State): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of State
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.State)))
	buf = append(buf, temp[:2]...)
	offset += len(m.State)

	// Field 4 (Country): string or bytes
	buf = append(buf, byte(4))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Country
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Country)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Country)

	offset += 4 // ZipCode

	// === DATA REGION SECTION ===

	// Write string or bytes field (StreetAddress)
	buf = append(buf, []byte(m.StreetAddress)...)

	// Write string or bytes field (City)
	buf = append(buf, []byte(m.City)...)

	// Write string or bytes field (State)
	buf = append(buf, []byte(m.State)...)

	// Write string or bytes field (Country)
	buf = append(buf, []byte(m.Country)...)

	// Write fixed field (ZipCode)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.ZipCode))
	buf = append(buf, temp[:4]...)

	return buf, nil
}

func (m *Address) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 6 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+5]
	offset += 5

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 20
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 4; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // StreetAddress
			// Unmarshal string or []byte field (StreetAddress)
			if entry, ok := offsets[1]; ok {
				m.StreetAddress = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // City
			// Unmarshal string or []byte field (City)
			if entry, ok := offsets[2]; ok {
				m.City = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 3: // State
			// Unmarshal string or []byte field (State)
			if entry, ok := offsets[3]; ok {
				m.State = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 4: // Country
			// Unmarshal string or []byte field (Country)
			if entry, ok := offsets[4]; ok {
				m.Country = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 5: // ZipCode
			// Unmarshal fixed field (ZipCode)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.ZipCode = int32(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		}
	}

	return nil
}

func (m *Money) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 66)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (CurrencyCode): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of CurrencyCode
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.CurrencyCode)))
	buf = append(buf, temp[:2]...)
	offset += len(m.CurrencyCode)

	offset += 8 // Units

	offset += 4 // Nanos

	// === DATA REGION SECTION ===

	// Write string or bytes field (CurrencyCode)
	buf = append(buf, []byte(m.CurrencyCode)...)

	// Write fixed field (Units)
	binary.LittleEndian.PutUint64(temp[:8], uint64(m.Units))
	buf = append(buf, temp[:8]...)

	// Write fixed field (Nanos)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.Nanos))
	buf = append(buf, temp[:4]...)

	return buf, nil
}

func (m *Money) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 4 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+3]
	offset += 3

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // CurrencyCode
			// Unmarshal string or []byte field (CurrencyCode)
			if entry, ok := offsets[1]; ok {
				m.CurrencyCode = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Units
			// Unmarshal fixed field (Units)
			if dataOffset+8 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Units = int64(binary.LittleEndian.Uint64(dataRegion[dataOffset : dataOffset+8]))
			dataOffset += 8
		case 3: // Nanos
			// Unmarshal fixed field (Nanos)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Nanos = int32(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		}
	}

	return nil
}

func (m *GetSupportedCurrenciesResponse) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (CurrencyCodes): repeated variable-length
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of CurrencyCodes
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.CurrencyCodes {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (CurrencyCodes)
	for _, item := range m.CurrencyCodes {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	return buf, nil
}

func (m *GetSupportedCurrenciesResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // CurrencyCodes
			// Unmarshal repeated variable-length field (CurrencyCodes)
			if entry, ok := offsets[1]; ok {
				m.CurrencyCodes = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.CurrencyCodes = append(m.CurrencyCodes, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.CurrencyCodes = append(m.CurrencyCodes, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *CurrencyConversionRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 183)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (From): singular message
	if m.From != nil {
		cachedSingularMessages[1], err = m.From.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field From: %w", err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (From): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[1])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[1])

	// Field 2 (ToCode): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of ToCode
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.ToCode)))
	buf = append(buf, temp[:2]...)
	offset += len(m.ToCode)

	// Field 3 (UserId): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of UserId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.UserId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.UserId)

	// === DATA REGION SECTION ===

	// Write nested message field (From)
	buf = append(buf, cachedSingularMessages[1]...)

	// Write string or bytes field (ToCode)
	buf = append(buf, []byte(m.ToCode)...)

	// Write string or bytes field (UserId)
	buf = append(buf, []byte(m.UserId)...)

	return buf, nil
}

func (m *CurrencyConversionRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 4 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+3]
	offset += 3

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 15
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 3; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // From
			// Unmarshal nested message field (From)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.From = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.From == nil {
						m.From = &Money{}
					}
					if err := m.From.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		case 2: // ToCode
			// Unmarshal string or []byte field (ToCode)
			if entry, ok := offsets[2]; ok {
				m.ToCode = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 3: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[3]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *CreditCardInfo) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 67)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (CreditCardNumber): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of CreditCardNumber
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.CreditCardNumber)))
	buf = append(buf, temp[:2]...)
	offset += len(m.CreditCardNumber)

	offset += 4 // CreditCardCvv

	offset += 4 // CreditCardExpirationYear

	offset += 4 // CreditCardExpirationMonth

	// === DATA REGION SECTION ===

	// Write string or bytes field (CreditCardNumber)
	buf = append(buf, []byte(m.CreditCardNumber)...)

	// Write fixed field (CreditCardCvv)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.CreditCardCvv))
	buf = append(buf, temp[:4]...)

	// Write fixed field (CreditCardExpirationYear)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.CreditCardExpirationYear))
	buf = append(buf, temp[:4]...)

	// Write fixed field (CreditCardExpirationMonth)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.CreditCardExpirationMonth))
	buf = append(buf, temp[:4]...)

	return buf, nil
}

func (m *CreditCardInfo) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 5 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+4]
	offset += 4

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // CreditCardNumber
			// Unmarshal string or []byte field (CreditCardNumber)
			if entry, ok := offsets[1]; ok {
				m.CreditCardNumber = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // CreditCardCvv
			// Unmarshal fixed field (CreditCardCvv)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.CreditCardCvv = int32(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		case 3: // CreditCardExpirationYear
			// Unmarshal fixed field (CreditCardExpirationYear)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.CreditCardExpirationYear = int32(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		case 4: // CreditCardExpirationMonth
			// Unmarshal fixed field (CreditCardExpirationMonth)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.CreditCardExpirationMonth = int32(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		}
	}

	return nil
}

func (m *ChargeRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 176)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (Amount): singular message
	if m.Amount != nil {
		cachedSingularMessages[1], err = m.Amount.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field Amount: %w", err)
		}
	}

	// Cache field 2 (CreditCard): singular message
	if m.CreditCard != nil {
		cachedSingularMessages[2], err = m.CreditCard.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field CreditCard: %w", err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Amount): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[1])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[1])

	// Field 2 (CreditCard): nested message
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[2])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[2])

	// === DATA REGION SECTION ===

	// Write nested message field (Amount)
	buf = append(buf, cachedSingularMessages[1]...)

	// Write nested message field (CreditCard)
	buf = append(buf, cachedSingularMessages[2]...)

	return buf, nil
}

func (m *ChargeRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Amount
			// Unmarshal nested message field (Amount)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.Amount = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Amount == nil {
						m.Amount = &Money{}
					}
					if err := m.Amount.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		case 2: // CreditCard
			// Unmarshal nested message field (CreditCard)
			if entry, ok := offsets[2]; ok {
				if entry.length == 0 {
					m.CreditCard = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.CreditCard == nil {
						m.CreditCard = &CreditCardInfo{}
					}
					if err := m.CreditCard.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ChargeResponse) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (TransactionId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of TransactionId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.TransactionId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.TransactionId)

	// === DATA REGION SECTION ===

	// Write string or bytes field (TransactionId)
	buf = append(buf, []byte(m.TransactionId)...)

	return buf, nil
}

func (m *ChargeResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // TransactionId
			// Unmarshal string or []byte field (TransactionId)
			if entry, ok := offsets[1]; ok {
				m.TransactionId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *OrderItem) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 176)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (Item): singular message
	if m.Item != nil {
		cachedSingularMessages[1], err = m.Item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field Item: %w", err)
		}
	}

	// Cache field 2 (Cost): singular message
	if m.Cost != nil {
		cachedSingularMessages[2], err = m.Cost.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field Cost: %w", err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Item): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[1])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[1])

	// Field 2 (Cost): nested message
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[2])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[2])

	// === DATA REGION SECTION ===

	// Write nested message field (Item)
	buf = append(buf, cachedSingularMessages[1]...)

	// Write nested message field (Cost)
	buf = append(buf, cachedSingularMessages[2]...)

	return buf, nil
}

func (m *OrderItem) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Item
			// Unmarshal nested message field (Item)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.Item = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Item == nil {
						m.Item = &CartItem{}
					}
					if err := m.Item.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		case 2: // Cost
			// Unmarshal nested message field (Cost)
			if entry, ok := offsets[2]; ok {
				if entry.length == 0 {
					m.Cost = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Cost == nil {
						m.Cost = &Money{}
					}
					if err := m.Cost.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *OrderResult) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 358)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4, 5}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 3 (ShippingCost): singular message
	if m.ShippingCost != nil {
		cachedSingularMessages[3], err = m.ShippingCost.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field ShippingCost: %w", err)
		}
	}

	// Cache field 4 (ShippingAddress): singular message
	if m.ShippingAddress != nil {
		cachedSingularMessages[4], err = m.ShippingAddress.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field ShippingAddress: %w", err)
		}
	}

	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 5 (Items): repeated message
	cachedRepeatedMessages[5] = make([][]byte, len(m.Items))
	for i, item := range m.Items {
		if item != nil {
			cachedRepeatedMessages[5][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, fmt.Errorf("failed to marshal repeated message field Items[%d]: %w", i, err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (OrderId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of OrderId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.OrderId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.OrderId)

	// Field 2 (ShippingTrackingId): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of ShippingTrackingId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.ShippingTrackingId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.ShippingTrackingId)

	// Field 3 (ShippingCost): nested message
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[3])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[3])

	// Field 4 (ShippingAddress): nested message
	buf = append(buf, byte(4))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[4])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[4])

	// Field 5 (Items): nested message
	buf = append(buf, byte(5))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range cachedRepeatedMessages[5] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (OrderId)
	buf = append(buf, []byte(m.OrderId)...)

	// Write string or bytes field (ShippingTrackingId)
	buf = append(buf, []byte(m.ShippingTrackingId)...)

	// Write nested message field (ShippingCost)
	buf = append(buf, cachedSingularMessages[3]...)

	// Write nested message field (ShippingAddress)
	buf = append(buf, cachedSingularMessages[4]...)

	// Write nested message field (Items)
	for _, item := range cachedRepeatedMessages[5] {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, item...)
	}

	return buf, nil
}

func (m *OrderResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 6 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+5]
	offset += 5

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 25
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 5; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // OrderId
			// Unmarshal string or []byte field (OrderId)
			if entry, ok := offsets[1]; ok {
				m.OrderId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // ShippingTrackingId
			// Unmarshal string or []byte field (ShippingTrackingId)
			if entry, ok := offsets[2]; ok {
				m.ShippingTrackingId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 3: // ShippingCost
			// Unmarshal nested message field (ShippingCost)
			if entry, ok := offsets[3]; ok {
				if entry.length == 0 {
					m.ShippingCost = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.ShippingCost == nil {
						m.ShippingCost = &Money{}
					}
					if err := m.ShippingCost.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		case 4: // ShippingAddress
			// Unmarshal nested message field (ShippingAddress)
			if entry, ok := offsets[4]; ok {
				if entry.length == 0 {
					m.ShippingAddress = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.ShippingAddress == nil {
						m.ShippingAddress = &Address{}
					}
					if err := m.ShippingAddress.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		case 5: // Items
			// Unmarshal nested message field (Items)
			if entry, ok := offsets[5]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Items = make([]*OrderItem, 0)
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.Items = append(m.Items, nil)
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item bytes")
					}
					itemBytes := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					newItem := &OrderItem{}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return fmt.Errorf("failed to unmarshal nested message: %w", err)
					}
					m.Items = append(m.Items, newItem)
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SendOrderConfirmationRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 136)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 2 (Order): singular message
	if m.Order != nil {
		cachedSingularMessages[2], err = m.Order.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field Order: %w", err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Email): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Email
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Email)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Email)

	// Field 2 (Order): nested message
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[2])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[2])

	// === DATA REGION SECTION ===

	// Write string or bytes field (Email)
	buf = append(buf, []byte(m.Email)...)

	// Write nested message field (Order)
	buf = append(buf, cachedSingularMessages[2]...)

	return buf, nil
}

func (m *SendOrderConfirmationRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Email
			// Unmarshal string or []byte field (Email)
			if entry, ok := offsets[1]; ok {
				m.Email = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Order
			// Unmarshal nested message field (Order)
			if entry, ok := offsets[2]; ok {
				if entry.length == 0 {
					m.Order = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Order == nil {
						m.Order = &OrderResult{}
					}
					if err := m.Order.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *PlaceOrderRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 318)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 5, 6}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 3 (Address): singular message
	if m.Address != nil {
		cachedSingularMessages[3], err = m.Address.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field Address: %w", err)
		}
	}

	// Cache field 6 (CreditCard): singular message
	if m.CreditCard != nil {
		cachedSingularMessages[6], err = m.CreditCard.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field CreditCard: %w", err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of UserId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.UserId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.UserId)

	// Field 2 (UserCurrency): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of UserCurrency
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.UserCurrency)))
	buf = append(buf, temp[:2]...)
	offset += len(m.UserCurrency)

	// Field 3 (Address): nested message
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[3])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[3])

	// Field 5 (Email): string or bytes
	buf = append(buf, byte(5))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Email
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Email)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Email)

	// Field 6 (CreditCard): nested message
	buf = append(buf, byte(6))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[6])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[6])

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf = append(buf, []byte(m.UserId)...)

	// Write string or bytes field (UserCurrency)
	buf = append(buf, []byte(m.UserCurrency)...)

	// Write nested message field (Address)
	buf = append(buf, cachedSingularMessages[3]...)

	// Write string or bytes field (Email)
	buf = append(buf, []byte(m.Email)...)

	// Write nested message field (CreditCard)
	buf = append(buf, cachedSingularMessages[6]...)

	return buf, nil
}

func (m *PlaceOrderRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 6 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+5]
	offset += 5

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 25
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 5; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // UserCurrency
			// Unmarshal string or []byte field (UserCurrency)
			if entry, ok := offsets[2]; ok {
				m.UserCurrency = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 3: // Address
			// Unmarshal nested message field (Address)
			if entry, ok := offsets[3]; ok {
				if entry.length == 0 {
					m.Address = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Address == nil {
						m.Address = &Address{}
					}
					if err := m.Address.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		case 5: // Email
			// Unmarshal string or []byte field (Email)
			if entry, ok := offsets[5]; ok {
				m.Email = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 6: // CreditCard
			// Unmarshal nested message field (CreditCard)
			if entry, ok := offsets[6]; ok {
				if entry.length == 0 {
					m.CreditCard = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.CreditCard == nil {
						m.CreditCard = &CreditCardInfo{}
					}
					if err := m.CreditCard.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *PlaceOrderResponse) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 88)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 1 (Order): singular message
	if m.Order != nil {
		cachedSingularMessages[1], err = m.Order.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field Order: %w", err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Order): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[1])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[1])

	// === DATA REGION SECTION ===

	// Write nested message field (Order)
	buf = append(buf, cachedSingularMessages[1]...)

	return buf, nil
}

func (m *PlaceOrderResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Order
			// Unmarshal nested message field (Order)
			if entry, ok := offsets[1]; ok {
				if entry.length == 0 {
					m.Order = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Order == nil {
						m.Order = &OrderResult{}
					}
					if err := m.Order.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *AdRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 96)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (UserId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of UserId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.UserId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.UserId)

	// Field 2 (ContextKeys): repeated variable-length
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of ContextKeys
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.ContextKeys {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (UserId)
	buf = append(buf, []byte(m.UserId)...)

	// Write repeated variable-length field (ContextKeys)
	for _, item := range m.ContextKeys {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	return buf, nil
}

func (m *AdRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // UserId
			// Unmarshal string or []byte field (UserId)
			if entry, ok := offsets[1]; ok {
				m.UserId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // ContextKeys
			// Unmarshal repeated variable-length field (ContextKeys)
			if entry, ok := offsets[2]; ok {
				m.ContextKeys = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.ContextKeys = append(m.ContextKeys, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.ContextKeys = append(m.ContextKeys, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *AdResponse) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 88)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 1 (Ads): repeated message
	cachedRepeatedMessages[1] = make([][]byte, len(m.Ads))
	for i, item := range m.Ads {
		if item != nil {
			cachedRepeatedMessages[1][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, fmt.Errorf("failed to marshal repeated message field Ads[%d]: %w", i, err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Ads): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range cachedRepeatedMessages[1] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Ads)
	for _, item := range cachedRepeatedMessages[1] {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, item...)
	}

	return buf, nil
}

func (m *AdResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Ads
			// Unmarshal nested message field (Ads)
			if entry, ok := offsets[1]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Ads = make([]*Ad, 0)
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.Ads = append(m.Ads, nil)
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item bytes")
					}
					itemBytes := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					newItem := &Ad{}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return fmt.Errorf("failed to unmarshal nested message: %w", err)
					}
					m.Ads = append(m.Ads, newItem)
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Ad) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 96)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (RedirectUrl): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of RedirectUrl
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.RedirectUrl)))
	buf = append(buf, temp[:2]...)
	offset += len(m.RedirectUrl)

	// Field 2 (Text): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Text
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Text)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Text)

	// === DATA REGION SECTION ===

	// Write string or bytes field (RedirectUrl)
	buf = append(buf, []byte(m.RedirectUrl)...)

	// Write string or bytes field (Text)
	buf = append(buf, []byte(m.Text)...)

	return buf, nil
}

func (m *Ad) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // RedirectUrl
			// Unmarshal string or []byte field (RedirectUrl)
			if entry, ok := offsets[1]; ok {
				m.RedirectUrl = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Text
			// Unmarshal string or []byte field (Text)
			if entry, ok := offsets[2]; ok {
				m.Text = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}
